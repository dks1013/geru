좋아요 👍 —
이 오류 Cannot read property 'apply' of null 은 Frida에서 자바 메서드를 후킹할 때 원본 구현(implementation)을 잘못 저장했거나, native 메서드라서 JS 함수 형태의 구현이 없을 때 생기는 전형적인 문제입니다.

즉, savedOrig (또는 orig) 변수가 null 혹은 undefined 상태이기 때문에 .apply()를 쓸 수 없다는 뜻이에요.


---

🔍 원인 정리

1. 해당 메서드가 Java 단이 아니라 native(C/C++)로 구현됨 → overload[i].implementation 자체가 null


2. implementation을 저장하기 전에 덮어씀 → savedOrig가 자기 자신(이미 교체된 함수)을 가리킴 → null 또는 undefined


3. Frida가 그 메서드를 JS로 감싸지 못한 경우 → (예: abstract, interface, bridge method 등)




---

✅ 해결 방법 ① (원본 호출 없이 단순 로그만 남기기)

테스트나 인자 확인 목적이라면 원본 호출을 생략하는 게 가장 간단하고 안전합니다.
이렇게 하면 apply 호출 자체가 필요 없어요.

// simple_log.js
Java.perform(function () {
    var className = "Test.test.test";
    var methodName = "toParamJSONString";

    try {
        var cls = Java.use(className);
        var overloads = cls[methodName].overloads;
        for (var i = 0; i < overloads.length; i++) {
            (function (idx) {
                overloads[idx].implementation = function () {
                    var first = arguments.length > 0 ? arguments[0] : "(no args)";
                    try {
                        console.log(
                            `[${className}.${methodName} overload ${idx}] 첫번째 인자:`,
                            first ? first.toString() : "null"
                        );
                    } catch (e) {
                        console.log("출력 실패:", e);
                    }

                    // 원본 호출 대신 그냥 null 리턴 (원본 유지 필요 없을 때)
                    return null;
                };
                console.log(`후킹 완료: ${methodName} overload[${idx}]`);
            })(i);
        }
    } catch (err) {
        console.log("오류:", err);
    }
});

이 버전은 단순히 호출 로그만 찍고 원본을 실행하지 않습니다.
(native나 추상 메서드도 안전하게 후킹됨)


---

✅ 해결 방법 ② (원본이 존재할 때만 안전하게 호출)

만약 원본을 반드시 호출해야 한다면, 다음처럼 “원본이 존재하는지 검사”를 추가하세요.

Java.perform(function () {
    var className = "Test.test.test";
    var methodName = "toParamJSONString";
    var cls = Java.use(className);
    var overloads = cls[methodName].overloads;

    for (var i = 0; i < overloads.length; i++) {
        (function (idx) {
            var hasOrig = overloads[idx].hasOwnProperty("implementation")
                && typeof overloads[idx].implementation === "function";
            var savedOrig = hasOrig ? overloads[idx].implementation : null;

            overloads[idx].implementation = function () {
                var first = arguments.length > 0 ? arguments[0] : "(no args)";
                console.log(`[${className}.${methodName} overload ${idx}] 첫번째 인자:`, first);

                if (savedOrig) {
                    try {
                        return savedOrig.apply(this, arguments);
                    } catch (e) {
                        console.log("원본 호출 실패:", e);
                    }
                } else {
                    console.log("원본 구현 없음 (native 또는 abstract)");
                }
                return null;
            };
            console.log(`후킹 완료: ${methodName} overload[${idx}]`);
        })(i);
    }
});

이 스크립트는 다음처럼 동작합니다:

원본이 존재하면 .apply() 호출

원본이 없으면 단순히 로그 출력 후 null 리턴



---

✅ 추가 확인법

문제 되는 메서드가 실제로 native인지 확인하려면 Frida 콘솔에서 아래처럼 실행해보세요:

frida -U -f com.example.app --no-pause

그리고 내부 REPL에서:

Java.perform(function(){
  var c = Java.use("Test.test.test");
  c.toParamJSONString.overloads.forEach(function(o){ console.log(o); });
});

→ 출력된 시그니처를 보면 native가 붙어있으면 원본 호출은 불가능합니다.
(예: public native java.lang.String toParamJSONString(java.lang.String arg))


---

🔧 결론

Cannot read property 'apply' of null → implementation이 없거나 null임

단순 로그만 찍을 경우 원본 호출 제거하면 100% 안전

원본 호출이 꼭 필요하면 null 체크 추가



---

원하신다면 해당 클래스(Test.test.test)의 toParamJSONString 시그니처(예: String toParamJSONString(String)인지 등)를 알려주시면, 정확한 오버로드 하나만 안전하게 후킹해서 원본 호출 유지하는 코드로 정리해드릴게요.

